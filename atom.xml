<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骁驰的杂货店</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lije024.github.io/"/>
  <updated>2019-04-29T04:28:54.755Z</updated>
  <id>http://lije024.github.io/</id>
  
  <author>
    <name>骁驰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>客户端Git版本管理流程分享</title>
    <link href="http://lije024.github.io/2019/04/29/%E5%AE%A2%E6%88%B7%E7%AB%AFGit%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B%E5%88%86%E4%BA%AB/"/>
    <id>http://lije024.github.io/2019/04/29/客户端Git版本管理流程分享/</id>
    <published>2019-04-29T02:47:49.000Z</published>
    <updated>2019-04-29T04:28:54.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端Git版本管理流程分享"><a href="#客户端Git版本管理流程分享" class="headerlink" title="客户端Git版本管理流程分享"></a>客户端Git版本管理流程分享</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">依托Git自身强大的Gitflow特性，我们可以更高效地进行团队内多人或者跨业务线之间的开发协作，   </div><div class="line">在需求版本开发中，可以进行对团队内每个成员的代码质量管控，互不干扰相互独立的需求开发，避免      </div><div class="line">多人代码糅合发生冲突或冗余需求下架污染发布版本带来的各种风险  </div><div class="line"></div><div class="line">Git分支管理分为常驻分支和临时分支</div></pre></td></tr></table></figure><h2 id="常驻分支"><a href="#常驻分支" class="headerlink" title="常驻分支"></a>常驻分支</h2><h3 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">该分支维护最稳定的线上版本，管理整个项目最新的生命周期，每次发版前在生产环境的测试就是在该  </div><div class="line">分支进行。</div><div class="line"></div><div class="line">代码来源：hotfix分支、develope版本分支</div><div class="line"></div><div class="line">每次发版打版本基于该分支打版本tag，tag命名规范如：master_7.0.3</div><div class="line"></div><div class="line">备注：开发人员切勿直接提交代码到该分支</div></pre></td></tr></table></figure><a id="more"></a><h3 id="develop分支"><a href="#develop分支" class="headerlink" title="develop分支"></a>develop分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">该分支派生于最新代码master分支，是所有业务线版本迭代共有的分支，保持所有bug修复和本次要  </div><div class="line">同时发版的各业务线功能代码</div><div class="line"></div><div class="line">代码来源：各业务线版本分支的合并</div><div class="line"></div><div class="line">备注：避免多业务线同时操作，可由管理人员负责</div></pre></td></tr></table></figure><h3 id="dev版本分支"><a href="#dev版本分支" class="headerlink" title="dev版本分支"></a>dev版本分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">该分支派生于develop分支，是当前业务线版本分支，不同的业务线可以由develop拉取各自的当前版本分支。</div><div class="line"></div><div class="line">代码来源：每个开发人员的feature分支合并或者push</div><div class="line"></div><div class="line">该分支常用于各业务线新功能测试</div></pre></td></tr></table></figure><h3 id="release分支"><a href="#release分支" class="headerlink" title="release分支"></a>release分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">该分支是预发布分支既所有业务线提测分支，常进行回归测试和兼容性测试</div><div class="line"></div><div class="line">等测试阶段结束，将该分支合并到develop和master上</div><div class="line"></div><div class="line">此处可能很多人会有疑问，已经有了develop分支为什么要有release分支，这个接下来会解释</div><div class="line"></div><div class="line">备注：本次业开发务负责人合并dev版本分支到该分支，避免多人操作</div></pre></td></tr></table></figure><h2 id="临时分支"><a href="#临时分支" class="headerlink" title="临时分支"></a>临时分支</h2><h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">该分支是每个负责开发新功能的同学自己由dev版本分支拉取</div><div class="line"></div><div class="line">命名规范：feature-功能命名</div><div class="line"></div><div class="line">建议：如果每个开发人员有很多个功能需求，建议每个功能拉取一个feature，做到功能之间互不干  </div><div class="line">扰，相互独立，避免多功能耦合在一起，避免开发中由于变动等因素出现不必要的拷贝、删除等操作风  </div><div class="line">险</div><div class="line"></div><div class="line">备注：由于考虑到feature会有很多，远程仓库只维护常驻分支，建议feature分支开发人员始终在  </div><div class="line">本地仓库维护，避免push到远端，万一不小心push，那就等feature合并或者push到dev版本分支  </div><div class="line">后，自己删除远端分支，至于本地如果自己觉得太多杂乱，可以直接删除</div></pre></td></tr></table></figure><h3 id="hotfix分支"><a href="#hotfix分支" class="headerlink" title="hotfix分支"></a>hotfix分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">该分支是用来在master阶段进行生产环境测试或者灰度时候，发现紧急bug后进行修复，等修复结束  </div><div class="line">后合并回develop和master，然后删除该分支</div></pre></td></tr></table></figure><h2 id="操作流程和常见case操作"><a href="#操作流程和常见case操作" class="headerlink" title="操作流程和常见case操作"></a>操作流程和常见case操作</h2><p><img src="/2019/04/29/客户端Git版本管理流程分享/Git版本管理.png" alt=""></p><h3 id="流程说明："><a href="#流程说明：" class="headerlink" title="流程说明："></a>流程说明：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">1、各业务线负责人从develop分支拉取版本分支dev_x.x.x  </div><div class="line"></div><div class="line">2、各业务线开发同学从dev_x.x.x拉取自己所需数量的本地feature-xxxx</div><div class="line"></div><div class="line">3、开发过程中dev_x.x.x有更新随时fetch并merge到自己的feature-xxx，这样避免好久没有  </div><div class="line">merge，突然需要依赖别人代码merge，极有可能会出现大量代码导致conflict（也可以通过fetch   </div><div class="line">dev_x.x.x到feature），结束后删除feature</div><div class="line"></div><div class="line">3、开发完某个任务并保证代码能够run起来，然后push代码或者merge到dev_x.x.x</div><div class="line"></div><div class="line">4、当到本业务线提测截止日期，负责人在dev_x.x.x上打包给测试进行新功能测试</div><div class="line"></div><div class="line">5、当新功能结束以后，负责人将dev_x.x.x merge到release分支，进行全app的回归测试</div><div class="line"></div><div class="line">6、等回归结束，负责人将release 同时merge到master和develop</div><div class="line"></div><div class="line">7、在master上进行生产环境测试或灰度，在此期间如果还有紧急重大bug出现，在master拉取  </div><div class="line">hotfix分支修复，完成后合并hotfix到master到develop，并删除分支</div><div class="line"></div><div class="line">8、发版本在master上打tag， master_x.x.x，代表线上版本号</div></pre></td></tr></table></figure><h3 id="常见case："><a href="#常见case：" class="headerlink" title="常见case："></a>常见case：</h3><h4 id="多业务线并行开发："><a href="#多业务线并行开发：" class="headerlink" title="多业务线并行开发："></a>多业务线并行开发：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">每个业务线如上流程</div></pre></td></tr></table></figure><h4 id="多业务线交叉开发"><a href="#多业务线交叉开发" class="headerlink" title="多业务线交叉开发"></a>多业务线交叉开发</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">如果多业务线提测日期不一样，发版时间不一样，如果有依赖前面业务线代码，有两种方式：</div><div class="line"></div><div class="line"> 1、等前者merge到develop，然后fetch/merge代码到自己的版本分支 </div><div class="line"></div><div class="line"> 2、 将前者新功能测试完成后没问题的版本分支直接merge到自己版本分支</div></pre></td></tr></table></figure><h4 id="为什么要适用release分支"><a href="#为什么要适用release分支" class="headerlink" title="为什么要适用release分支"></a>为什么要适用release分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">假如没有release，所有业务线同时操作develop分支，不小心有大量冲突或者需求错误要回溯，当  </div><div class="line">此时又有一个业务线要开始建版本分支开发，此时因为develop还没修复耽误别人开发，如果存在  </div><div class="line">release就不会影响develop别的业务线开发，所有问题都在release测试分支全部处理</div></pre></td></tr></table></figure><h4 id="为什么要在本地建feature-xxx"><a href="#为什么要在本地建feature-xxx" class="headerlink" title="为什么要在本地建feature-xxx"></a>为什么要在本地建feature-xxx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果没有业务组件化，feature-xxx要建本地分支，尽可能不要推到远端，如果误操作，结束可以删  </div><div class="line">除远端和本地，这样做好处是：多人直接操作版本分支而造成工程无法run，影响别人开发，尽可能将  </div><div class="line">conflict解决在本地feature</div></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1、以上流程可以避免产品需求回溯，增加紧急需求，紧急bug修复，远端代码回溯，多人操作稳定分  </div><div class="line">支develop造成无法预估的开发风险</div><div class="line"></div><div class="line">2、切勿直接操作master和develop分支</div></pre></td></tr></table></figure><p>以上是我大概的一点工作心得，如有不妥之处，望指正</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;客户端Git版本管理流程分享&quot;&gt;&lt;a href=&quot;#客户端Git版本管理流程分享&quot; class=&quot;headerlink&quot; title=&quot;客户端Git版本管理流程分享&quot;&gt;&lt;/a&gt;客户端Git版本管理流程分享&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;依托Git自身强大的Gitflow特性，我们可以更高效地进行团队内多人或者跨业务线之间的开发协作，   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;在需求版本开发中，可以进行对团队内每个成员的代码质量管控，互不干扰相互独立的需求开发，避免      &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;多人代码糅合发生冲突或冗余需求下架污染发布版本带来的各种风险  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Git分支管理分为常驻分支和临时分支&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;常驻分支&quot;&gt;&lt;a href=&quot;#常驻分支&quot; class=&quot;headerlink&quot; title=&quot;常驻分支&quot;&gt;&lt;/a&gt;常驻分支&lt;/h2&gt;&lt;h3 id=&quot;master分支&quot;&gt;&lt;a href=&quot;#master分支&quot; class=&quot;headerlink&quot; title=&quot;master分支&quot;&gt;&lt;/a&gt;master分支&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;该分支维护最稳定的线上版本，管理整个项目最新的生命周期，每次发版前在生产环境的测试就是在该  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;分支进行。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;代码来源：hotfix分支、develope版本分支&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;每次发版打版本基于该分支打版本tag，tag命名规范如：master_7.0.3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;备注：开发人员切勿直接提交代码到该分支&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="git版本管理" scheme="http://lije024.github.io/categories/git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://lije024.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>涂鸦功能需求分析</title>
    <link href="http://lije024.github.io/2017/11/09/%E6%B6%82%E9%B8%A6%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>http://lije024.github.io/2017/11/09/涂鸦功能需求分析/</id>
    <published>2017-11-09T09:19:05.000Z</published>
    <updated>2017-11-09T09:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="涂鸦功能需求分析"><a href="#涂鸦功能需求分析" class="headerlink" title="涂鸦功能需求分析"></a>涂鸦功能需求分析</h1><ul><li><p>在短视频进入编辑界面的时候在视频预览播放层上用户点击涂鸦按钮调出涂鸦面板。</p></li><li><p>在涂鸦面板为第一次响应的时候，编辑界面面板不响应。</p></li><li><p>涂鸦过程中可以选择画笔颜色，同时可以调节画笔宽度。</p></li><li><p>用户可以撤销涂鸦，进行清屏操作。</p></li></ul><h1 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h1><ul><li>涂鸦功能涉及到iOS开发Cocoa框架中绘图操作。</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="一、UIBezierPath-绘制画板方法"><a href="#一、UIBezierPath-绘制画板方法" class="headerlink" title="一、UIBezierPath 绘制画板方法"></a>一、UIBezierPath 绘制画板方法</h2><h3 id="UIBerierPath的原理"><a href="#UIBerierPath的原理" class="headerlink" title="UIBerierPath的原理"></a>UIBerierPath的原理</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、 UIBezierPath使用UIBezierPath可以创建基于矢量的路径，此类是Core Graphics框架关于路径的封装。使用此类可以定义简单的形状，如椭圆、矩形或者有多个直线和曲线段组成的形状等。</div><div class="line"></div><div class="line"><span class="number">2</span>、UIBezierPath是CGPathRef数据类型的封装。如果是基于矢量形状的路径，都用直线和曲线去创建。我们使用直线段去创建矩形和多边形，使用曲线去创建圆弧（arc）、圆或者其他复杂的曲线形状。</div><div class="line"></div><div class="line"><span class="number">3</span>、使用UIBezierPath画图步骤：</div><div class="line"></div><div class="line">创建一个UIBezierPath对象</div><div class="line"></div><div class="line">调用-<span class="symbol">moveToPoint:</span>设置初始线段的起点</div><div class="line"></div><div class="line">添加线或者曲线去定义一个或者多个子路径</div><div class="line"></div><div class="line">改变UIBezierPath对象跟绘图相关的属性。如，我们可以设置画笔的属性、填充样式等。</div></pre></td></tr></table></figure><a id="more"></a><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">创建一继承自UIBerierPath的子类，在子类中用两个属性分别记录画笔的颜色和是否为清除涂鸦路径操作。</div><div class="line"></div><div class="line">   @property (nonatomic,copy) UIColor *lineColor; <span class="regexp">//</span> 画笔的颜色</div><div class="line">   @property (nonatomic,assign) BOOL isCleanScreen; <span class="regexp">//</span> 是否撤销</div></pre></td></tr></table></figure><p>需要实现的API</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)<span class="symbol">touchesBegan:</span>(NSSet *)touches <span class="symbol">withEvent:</span>(UIEvent *)event;</div><div class="line">- (void)<span class="symbol">touchesMoved:</span>(NSSet&lt;UITouch *&gt; *)touches <span class="symbol">withEvent:</span>(UIEvent *)event;</div><div class="line">- (void)<span class="symbol">touchesEnded:</span>(NSSet&lt;UITouch *&gt; *)touches <span class="symbol">withEvent:</span>(UIEvent *)event;</div></pre></td></tr></table></figure><p>最核心的API： <code>**drawRect**</code>方法的重写</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)<span class="symbol">drawRect:</span>(CGRect)rect &#123;</div><div class="line">  /<span class="regexp">/ 设置画笔颜色</span></div><div class="line"><span class="regexp">  /</span><span class="regexp">/ 设置画线模式</span></div><div class="line"><span class="regexp">  </span></div><div class="line"><span class="regexp">  [path stroke];</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><h2 id="二、还有两种涂鸦实现方法："><a href="#二、还有两种涂鸦实现方法：" class="headerlink" title="二、还有两种涂鸦实现方法："></a>二、还有两种涂鸦实现方法：</h2><h3 id="1、系统绘图库-NSUndoManager-Quartz2D实现。"><a href="#1、系统绘图库-NSUndoManager-Quartz2D实现。" class="headerlink" title="1、系统绘图库 NSUndoManager + Quartz2D实现。"></a>1、系统绘图库 NSUndoManager + Quartz2D实现。</h3><h3 id="2、使用OpenGLES实现。"><a href="#2、使用OpenGLES实现。" class="headerlink" title="2、使用OpenGLES实现。"></a>2、使用OpenGLES实现。</h3><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>对于简单一次性绘制涂鸦需求，可以采用第一种方案，方案一API具有高度封装性使用成本比较低，如果不会重复绘制，不会有很大的性能问题产生。</p></li><li><p>如果追求很流畅的绘制效率，采用第二种方案。方案二绘制效率高，偏底层，绘制速度快，但因为偏于底层，对于重复绘制会比较耗性能，计算频繁会出现延迟断点问题。</p></li><li><p>方案三更偏底层，很多需求需要用OpenGL自定义开发，成本高，出现问题不容易解决，优点是绘制速度更快，更流畅。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;涂鸦功能需求分析&quot;&gt;&lt;a href=&quot;#涂鸦功能需求分析&quot; class=&quot;headerlink&quot; title=&quot;涂鸦功能需求分析&quot;&gt;&lt;/a&gt;涂鸦功能需求分析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在短视频进入编辑界面的时候在视频预览播放层上用户点击涂鸦按钮调出涂鸦面板。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在涂鸦面板为第一次响应的时候，编辑界面面板不响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;涂鸦过程中可以选择画笔颜色，同时可以调节画笔宽度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户可以撤销涂鸦，进行清屏操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;技术背景&quot;&gt;&lt;a href=&quot;#技术背景&quot; class=&quot;headerlink&quot; title=&quot;技术背景&quot;&gt;&lt;/a&gt;技术背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;涂鸦功能涉及到iOS开发Cocoa框架中绘图操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h1&gt;&lt;h2 id=&quot;一、UIBezierPath-绘制画板方法&quot;&gt;&lt;a href=&quot;#一、UIBezierPath-绘制画板方法&quot; class=&quot;headerlink&quot; title=&quot;一、UIBezierPath 绘制画板方法&quot;&gt;&lt;/a&gt;一、UIBezierPath 绘制画板方法&lt;/h2&gt;&lt;h3 id=&quot;UIBerierPath的原理&quot;&gt;&lt;a href=&quot;#UIBerierPath的原理&quot; class=&quot;headerlink&quot; title=&quot;UIBerierPath的原理&quot;&gt;&lt;/a&gt;UIBerierPath的原理&lt;/h3&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、 UIBezierPath使用UIBezierPath可以创建基于矢量的路径，此类是Core Graphics框架关于路径的封装。使用此类可以定义简单的形状，如椭圆、矩形或者有多个直线和曲线段组成的形状等。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、UIBezierPath是CGPathRef数据类型的封装。如果是基于矢量形状的路径，都用直线和曲线去创建。我们使用直线段去创建矩形和多边形，使用曲线去创建圆弧（arc）、圆或者其他复杂的曲线形状。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;、使用UIBezierPath画图步骤：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;创建一个UIBezierPath对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;调用-&lt;span class=&quot;symbol&quot;&gt;moveToPoint:&lt;/span&gt;设置初始线段的起点&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;添加线或者曲线去定义一个或者多个子路径&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;改变UIBezierPath对象跟绘图相关的属性。如，我们可以设置画笔的属性、填充样式等。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="多媒体开发" scheme="http://lije024.github.io/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="UIBerizerPath" scheme="http://lije024.github.io/tags/UIBerizerPath/"/>
    
      <category term="Quart2D" scheme="http://lije024.github.io/tags/Quart2D/"/>
    
      <category term="OpenGlES" scheme="http://lije024.github.io/tags/OpenGlES/"/>
    
      <category term="涂鸦画板" scheme="http://lije024.github.io/tags/%E6%B6%82%E9%B8%A6%E7%94%BB%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>视频添加文字和贴纸需求分析</title>
    <link href="http://lije024.github.io/2017/11/09/%E8%A7%86%E9%A2%91%E6%B7%BB%E5%8A%A0%E6%96%87%E5%AD%97%E5%92%8C%E8%B4%B4%E7%BA%B8%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>http://lije024.github.io/2017/11/09/视频添加文字和贴纸需求分析/</id>
    <published>2017-11-09T09:16:00.000Z</published>
    <updated>2017-11-09T09:32:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视频添加文字和贴纸需求分析"><a href="#视频添加文字和贴纸需求分析" class="headerlink" title="视频添加文字和贴纸需求分析"></a>视频添加文字和贴纸需求分析</h1><ul><li><p>贴纸除了天气海拔等物理来源之外，需要通过服务下载贴纸资源，外加内置系统表情。</p></li><li><p>在视频编辑界面添加贴纸层，对贴纸进行拖动、缩放、旋转、删除操作。</p></li><li><p>在视频编辑界面添加文字层，可以改变文字颜色，拖、缩放、旋转、删除操作。</p></li></ul><h1 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h1><ul><li><p>对贴纸和文字进行操作，涉及到iOS <code>UIGestureRecongizer</code>手势响应的管理。</p></li><li><p>对文字视图做操作编辑状态下恢复原状，涉及iOS仿射变换知识。</p></li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>在视图对象上添加手势，并且在各个手势selector API里面实现对视图的控制。</p><h3 id="一、利用UIGestureRecongizer方法"><a href="#一、利用UIGestureRecongizer方法" class="headerlink" title="一、利用UIGestureRecongizer方法"></a>一、利用UIGestureRecongizer方法</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/<span class="regexp">/ 添加所有的手势  </span></div><div class="line"><span class="regexp">- (void) addGestureRecognizerToView:(UIView *)view &#123;  </span></div><div class="line"><span class="regexp">    /</span><span class="regexp">/ 旋转手势  </span></div><div class="line"><span class="regexp">    UIRotationGestureRecognizer *rotationGestureRecognizer = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotateView:)];  </span></div><div class="line"><span class="regexp">    [view addGestureRecognizer:rotationGestureRecognizer];  </span></div><div class="line"><span class="regexp">      </span></div><div class="line"><span class="regexp">    /</span><span class="regexp">/ 缩放手势  </span></div><div class="line"><span class="regexp">    UIPinchGestureRecognizer *pinchGestureRecognizer = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinchView:)];  </span></div><div class="line"><span class="regexp">    [view addGestureRecognizer:pinchGestureRecognizer];  </span></div><div class="line"><span class="regexp">      </span></div><div class="line"><span class="regexp">    /</span><span class="regexp">/ 移动手势  </span></div><div class="line"><span class="regexp">    UIPanGestureRecognizer *panGestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panView:)];  </span></div><div class="line"><span class="regexp">    [view addGestureRecognizer:panGestureRecognizer];  </span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><a id="more"></a><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/<span class="regexp">/ 处理旋转手势  </span></div><div class="line"><span class="regexp">- (void) rotateView:(UIRotationGestureRecognizer *)rotationGestureRecognizer &#123;  </span></div><div class="line"><span class="regexp">    UIView *view = rotationGestureRecognizer.view;  </span></div><div class="line"><span class="regexp">    if (rotationGestureRecognizer.state == UIGestureRecognizerStateBegan || rotationGestureRecognizer.state == UIGestureRecognizerStateChanged) &#123;  </span></div><div class="line"><span class="regexp">        view.transform = CGAffineTransformRotate(view.transform, rotationGestureRecognizer.rotation);  </span></div><div class="line"><span class="regexp">        [rotationGestureRecognizer setRotation:0];  </span></div><div class="line"><span class="regexp">    &#125;  </span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/<span class="regexp">/ 处理缩放手势  </span></div><div class="line"><span class="regexp">- (void) pinchView:(UIPinchGestureRecognizer *)pinchGestureRecognizer &#123;  </span></div><div class="line"><span class="regexp">    UIView *view = pinchGestureRecognizer.view;  </span></div><div class="line"><span class="regexp">    if (pinchGestureRecognizer.state == UIGestureRecognizerStateBegan || pinchGestureRecognizer.state == UIGestureRecognizerStateChanged) &#123;  </span></div><div class="line"><span class="regexp">        view.transform = CGAffineTransformScale(view.transform, pinchGestureRecognizer.scale, pinchGestureRecognizer.scale);  </span></div><div class="line"><span class="regexp">        pinchGestureRecognizer.scale = 1;  </span></div><div class="line"><span class="regexp">    &#125;  </span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/<span class="regexp">/ 处理拖拉手势  </span></div><div class="line"><span class="regexp">- (void) panView:(UIPanGestureRecognizer *)panGestureRecognizer &#123;  </span></div><div class="line"><span class="regexp">    UIView *view = panGestureRecognizer.view;  </span></div><div class="line"><span class="regexp">    if (panGestureRecognizer.state == UIGestureRecognizerStateBegan || panGestureRecognizer.state == UIGestureRecognizerStateChanged) &#123;  </span></div><div class="line"><span class="regexp">        CGPoint translation = [panGestureRecognizer translationInView:view.superview];  </span></div><div class="line"><span class="regexp">        [view setCenter:(CGPoint)&#123;view.center.x + translation.x, view.center.y + translation.y&#125;];  </span></div><div class="line"><span class="regexp">        [panGestureRecognizer setTranslation:CGPointZero inView:view.superview];  </span></div><div class="line"><span class="regexp">    &#125;  </span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><h3 id="二、利用仿射变换实现"><a href="#二、利用仿射变换实现" class="headerlink" title="二、利用仿射变换实现"></a>二、利用仿射变换实现</h3><p>1、CGAffineTransformMake  //直接创建变换</p><p>2、CGAffineTransformMakeScale  //创建一个给定比例放缩的变换</p><p><code>CGAffineTransform CGAffineTransformMakeScale (CGFloat sx, CGFloat sy);</code>可以看到这个参数就少多了，也比较好理解，假设是一个图片视图引用了这个变换，那么图片的宽度就会变为width<em>sx ，对应高度变为hight </em> sy。</p><p>3、CGAffineTransformMakeRotation  //创建一个旋转角度的变化</p><p><code>CGAffineTransform CGAffineTransformMakeRotation ( CGFloat angle);</code>在这里可以看到参数并不是一个角度，但是它是把参数作为一个弧度，然后把弧度再转换为角度来处理，<br>其结果就可能是将一个图片视图旋转了多少度。</p><p>4、CGAffineTransformMakeTranslation  //创建一个平移的变化</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于文字进行缩放、旋转、平移操作之外，编辑状态下要还原原始状态，所以需要仿射变换和手势相结合。但也可以完全通过仿射变换实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;视频添加文字和贴纸需求分析&quot;&gt;&lt;a href=&quot;#视频添加文字和贴纸需求分析&quot; class=&quot;headerlink&quot; title=&quot;视频添加文字和贴纸需求分析&quot;&gt;&lt;/a&gt;视频添加文字和贴纸需求分析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;贴纸除了天气海拔等物理来源之外，需要通过服务下载贴纸资源，外加内置系统表情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在视频编辑界面添加贴纸层，对贴纸进行拖动、缩放、旋转、删除操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在视频编辑界面添加文字层，可以改变文字颜色，拖、缩放、旋转、删除操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;技术背景&quot;&gt;&lt;a href=&quot;#技术背景&quot; class=&quot;headerlink&quot; title=&quot;技术背景&quot;&gt;&lt;/a&gt;技术背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对贴纸和文字进行操作，涉及到iOS &lt;code&gt;UIGestureRecongizer&lt;/code&gt;手势响应的管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对文字视图做操作编辑状态下恢复原状，涉及iOS仿射变换知识。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h1&gt;&lt;p&gt;在视图对象上添加手势，并且在各个手势selector API里面实现对视图的控制。&lt;/p&gt;
&lt;h3 id=&quot;一、利用UIGestureRecongizer方法&quot;&gt;&lt;a href=&quot;#一、利用UIGestureRecongizer方法&quot; class=&quot;headerlink&quot; title=&quot;一、利用UIGestureRecongizer方法&quot;&gt;&lt;/a&gt;一、利用UIGestureRecongizer方法&lt;/h3&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/&lt;span class=&quot;regexp&quot;&gt;/ 添加所有的手势  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;- (void) addGestureRecognizerToView:(UIView *)view &amp;#123;  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ 旋转手势  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    UIRotationGestureRecognizer *rotationGestureRecognizer = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotateView:)];  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    [view addGestureRecognizer:rotationGestureRecognizer];  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;      &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ 缩放手势  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    UIPinchGestureRecognizer *pinchGestureRecognizer = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinchView:)];  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    [view addGestureRecognizer:pinchGestureRecognizer];  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;      &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ 移动手势  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    UIPanGestureRecognizer *panGestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panView:)];  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    [view addGestureRecognizer:panGestureRecognizer];  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="多媒体开发" scheme="http://lije024.github.io/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="仿射变换" scheme="http://lije024.github.io/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"/>
    
      <category term="UIGestureRecognizer" scheme="http://lije024.github.io/tags/UIGestureRecognizer/"/>
    
  </entry>
  
  <entry>
    <title>ios深浅拷贝</title>
    <link href="http://lije024.github.io/2016/04/20/ios%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://lije024.github.io/2016/04/20/ios深浅拷贝/</id>
    <published>2016-04-20T04:02:02.000Z</published>
    <updated>2017-10-18T08:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在对于自定义的对象支持copy功能，也就是我们要给自定义的对象发送copy message,那我们就要手动实现NSCopying协议。在项目开发中我们如果对某个字典或者数组对象进行了一次mutbleCopy其实系统默认的调用了如下API:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)<span class="symbol">mutableCopyWithZone:</span>(nullable NSZone *)zone;</div></pre></td></tr></table></figure><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>如果你现在通过retain或者alloc创建并持有了一个对象，浅拷贝就是重新拷贝了一个指向当前这个对象的指针，此时就有两份指针同时指向当前对象的内存区域，即指向同一块内存区域，对象只有一份并没有发生任何变化。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *hdfString = @<span class="string">"haodf.com"</span>;</div><div class="line">NSString *str = hdfString;</div><div class="line">NSString *str2 = [str copy];</div></pre></td></tr></table></figure><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>深拷贝拷贝当前指针指向的对象，系统会随机给拷贝的对象重新分配一块内存，深拷贝以后，两份对象的内存地址不一样，指针指向也不一样。深拷贝会把当前容器中的对象重新拷贝一份放到另一个容器中，拷贝后的指针指向新的容器。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *hdfString = @<span class="string">"haodf.com"</span>;</div><div class="line">NSString *str = [hdfString copy];</div><div class="line">NSString *str2 = [str mutableCopy];</div></pre></td></tr></table></figure><a id="more"></a><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p> 1、对不可变的对象进行mutableCopy操作,是进行了一次深拷贝，返回的对象是可变的对象。</p><p> 2、对不可变的对象进行copy操作，进行了一次浅拷贝，返回一个不可变的对象。</p><p> 3、对可变得对象进行copy，进行了深拷贝，返回的是可变的对象。</p><p> 4、 对可变的对象进行了一次mutableCopy，是进行了一次深拷贝， 返回的对象是一个可变的对象。</p><p> 5、想要让自定义的对象支持copy和mutableCopy那么就要对应实现NSCopying协议，和NSMutableCopying协议。</p><h1 id="retain和copy的区别："><a href="#retain和copy的区别：" class="headerlink" title="retain和copy的区别："></a>retain和copy的区别：</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、retain是对当前对象增加了一个指针指向，使对象的引用计数器加<span class="number">1</span>， 是进行了一次安全的浅拷贝操作。</div><div class="line"><span class="number">2</span>、copy是对当前对象进行了一次拷贝，重新拷贝了当前对象，当使用的时候减少了对当前对象的依赖。</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在对于自定义的对象支持copy功能，也就是我们要给自定义的对象发送copy message,那我们就要手动实现NSCopying协议。在项目开发中我们如果对某个字典或者数组对象进行了一次mutbleCopy其实系统默认的调用了如下API:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (id)&lt;span class=&quot;symbol&quot;&gt;mutableCopyWithZone:&lt;/span&gt;(nullable NSZone *)zone;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h1&gt;&lt;p&gt;如果你现在通过retain或者alloc创建并持有了一个对象，浅拷贝就是重新拷贝了一个指向当前这个对象的指针，此时就有两份指针同时指向当前对象的内存区域，即指向同一块内存区域，对象只有一份并没有发生任何变化。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSString *hdfString = @&lt;span class=&quot;string&quot;&gt;&quot;haodf.com&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSString *str = hdfString;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSString *str2 = [str copy];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;深拷贝&quot;&gt;&lt;a href=&quot;#深拷贝&quot; class=&quot;headerlink&quot; title=&quot;深拷贝&quot;&gt;&lt;/a&gt;深拷贝&lt;/h1&gt;&lt;p&gt;深拷贝拷贝当前指针指向的对象，系统会随机给拷贝的对象重新分配一块内存，深拷贝以后，两份对象的内存地址不一样，指针指向也不一样。深拷贝会把当前容器中的对象重新拷贝一份放到另一个容器中，拷贝后的指针指向新的容器。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSString *hdfString = @&lt;span class=&quot;string&quot;&gt;&quot;haodf.com&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSString *str = [hdfString copy];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSString *str2 = [str mutableCopy];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Foundation" scheme="http://lije024.github.io/categories/Foundation/"/>
    
    
      <category term="mutableCopy" scheme="http://lije024.github.io/tags/mutableCopy/"/>
    
      <category term="copy" scheme="http://lije024.github.io/tags/copy/"/>
    
  </entry>
  
  <entry>
    <title>图片的压缩方式</title>
    <link href="http://lije024.github.io/2016/03/14/%E5%9B%BE%E7%89%87%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F/"/>
    <id>http://lije024.github.io/2016/03/14/图片的压缩方式/</id>
    <published>2016-03-14T08:23:27.000Z</published>
    <updated>2017-10-18T08:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在我们项目开发中我们经常会遇到关于图片的处理。</p><p>在图片上传中我们会从用户体验方面考虑用户的流量是否能够很好的支持上传的图片，我们会对图片先压缩后上传。</p><p>当我们考虑到手机的本身内存我们会对下载的图片进行压缩，以便节省手机内存成本。</p><h1 id="读取图片的方式"><a href="#读取图片的方式" class="headerlink" title="读取图片的方式"></a>读取图片的方式</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、UIImageJPEGRepresentation()此API需要两个参数，一个是图片对象，一个是压缩系数，但是图片的质量会有所下降，但是体积不会变。</div><div class="line"><span class="number">2</span>、UIImagePNGRepresentation()，只需要一个图片的对象参数，不会对图片压缩，原图展示。</div></pre></td></tr></table></figure><h1 id="对图片的质量进行压缩"><a href="#对图片的质量进行压缩" class="headerlink" title="对图片的质量进行压缩"></a>对图片的质量进行压缩</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、UIImageJPEGRepresentation()返回的数据量要比UIImagePNGRepresentation()大很多，前者返回的数据量要比后者小很多，前者返回的数据量大概是<span class="number">115</span>kb，后者返回的数据大概为<span class="number">190</span>kb，相差很大。</div><div class="line"><span class="number">2</span>、如果对UIImageJPEGRepresentation()的系数设置为<span class="number">0</span>.<span class="number">5</span>，再加上本身不是很追求图片的质量，那么会大大节省图片的资源大小，大概为<span class="number">11</span>kb。</div><div class="line"></div><div class="line">+ (UIImage *)<span class="symbol">resuceImage:</span>(UIImage *)hdfImage <span class="symbol">percent:</span>(CGFloat)percent &#123;</div><div class="line">  UIImage *image = <span class="literal">nil</span>;</div><div class="line">  NSData *data = <span class="literal">nil</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span>(hdfImage) &#123;</div><div class="line">   data = UIImageJPEGRepresentation(hdfImage, percent);</div><div class="line">   image = [UIImage <span class="symbol">imageWithData:</span>data];</div><div class="line">  &#125; </div><div class="line">  </div><div class="line">  <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h1 id="压缩图片到指定的尺寸"><a href="#压缩图片到指定的尺寸" class="headerlink" title="压缩图片到指定的尺寸"></a>压缩图片到指定的尺寸</h1><p>我们传入理想的图片尺寸即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)<span class="symbol">reduceImage:</span>(UIImge *)hdfImage <span class="symbol">reduceSize:</span>(CGSize)reduceSize &#123;</div><div class="line">  UIGraphicsBeginImageContext(reduceSize);</div><div class="line">  </div><div class="line">  UIIMage *image = <span class="literal">nil</span>;</div><div class="line">  <span class="keyword">if</span>(hdfImage) &#123;</div><div class="line">    [image <span class="symbol">drawInRect:</span>CGRectMake(<span class="number">0</span>, <span class="number">0</span>, reduceSize.width, reducdeSize.height)];</div><div class="line">    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">  &#125;</div><div class="line">   <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="等比例压缩图片"><a href="#等比例压缩图片" class="headerlink" title="等比例压缩图片"></a>等比例压缩图片</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">-(UIImage *) <span class="symbol">imageCompressForWidth:</span>(UIImage *)sourceImage <span class="symbol">targetWidth:</span>(CGFloat)defineWidth &#123;</div><div class="line">    UIImage *newImage = <span class="literal">nil</span>;</div><div class="line">    CGSize imageSize = sourceImage.size;</div><div class="line">    CGFloat width = imageSize.width;</div><div class="line">    CGFloat height = imageSize.height;</div><div class="line">    CGFloat targetWidth = defineWidth;</div><div class="line">    CGFloat targetHeight = height / (width / targetWidth);</div><div class="line">    CGSize size = CGSizeMake(targetWidth, targetHeight);</div><div class="line">    CGFloat scaleFactor = <span class="number">0</span>.<span class="number">0</span>;</div><div class="line">    CGFloat scaledWidth = targetWidth;</div><div class="line">    CGFloat scaledHeight = targetHeight;</div><div class="line">    CGPoint thumbnailPoint = CGPointMake(<span class="number">0</span>.<span class="number">0</span>, <span class="number">0</span>.<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(CGSizeEqualToSize(imageSize, size) == NO)&#123;</div><div class="line">        CGFloat widthFactor = targetWidth / width;</div><div class="line">        CGFloat heightFactor = targetHeight / height;</div><div class="line">    <span class="keyword">if</span>(widthFactor &gt; heightFactor)&#123;</div><div class="line">        scaleFactor = widthFactor;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        scaleFactor = heightFactor;</div><div class="line">    &#125;</div><div class="line">    scaledWidth = width * scaleFactor;</div><div class="line">    scaledHeight = height * scaleFactor;</div><div class="line">    <span class="keyword">if</span>(widthFactor &gt; heightFactor)&#123;</div><div class="line">        thumbnailPoint.y = (targetHeight - scaledHeight) * <span class="number">0</span>.<span class="number">5</span>;</div><div class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(widthFactor &lt; heightFactor)&#123;</div><div class="line">        thumbnailPoint.x = (targetWidth - scaledWidth) * <span class="number">0</span>.<span class="number">5</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    UIGraphicsBeginImageContext(size);</div><div class="line">    CGRect thumbnailRect = CGRectZero;</div><div class="line">    thumbnailRect.origin = thumbnailPoint;</div><div class="line">    thumbnailRect.size.width = scaledWidth;</div><div class="line">    thumbnailRect.size.height = scaledHeight;</div><div class="line"></div><div class="line">    [sourceImage <span class="symbol">drawInRect:</span>thumbnailRect];</div><div class="line"></div><div class="line">    newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    <span class="keyword">if</span>(newImage == <span class="literal">nil</span>)&#123;</div><div class="line">       NSLog(@<span class="string">"scale image fail"</span>);</div><div class="line">    &#125;</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    <span class="keyword">return</span> newImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在我们项目开发中我们经常会遇到关于图片的处理。&lt;/p&gt;
&lt;p&gt;在图片上传中我们会从用户体验方面考虑用户的流量是否能够很好的支持上传的图片，我们会对图片先压缩后上传。&lt;/p&gt;
&lt;p&gt;当我们考虑到手机的本身内存我们会对下载的图片进行压缩，以便节省手机内存成本。&lt;/p&gt;
&lt;h1 id=&quot;读取图片的方式&quot;&gt;&lt;a href=&quot;#读取图片的方式&quot; class=&quot;headerlink&quot; title=&quot;读取图片的方式&quot;&gt;&lt;/a&gt;读取图片的方式&lt;/h1&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、UIImageJPEGRepresentation()此API需要两个参数，一个是图片对象，一个是压缩系数，但是图片的质量会有所下降，但是体积不会变。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、UIImagePNGRepresentation()，只需要一个图片的对象参数，不会对图片压缩，原图展示。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;对图片的质量进行压缩&quot;&gt;&lt;a href=&quot;#对图片的质量进行压缩&quot; class=&quot;headerlink&quot; title=&quot;对图片的质量进行压缩&quot;&gt;&lt;/a&gt;对图片的质量进行压缩&lt;/h1&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、UIImageJPEGRepresentation()返回的数据量要比UIImagePNGRepresentation()大很多，前者返回的数据量要比后者小很多，前者返回的数据量大概是&lt;span class=&quot;number&quot;&gt;115&lt;/span&gt;kb，后者返回的数据大概为&lt;span class=&quot;number&quot;&gt;190&lt;/span&gt;kb，相差很大。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、如果对UIImageJPEGRepresentation()的系数设置为&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;，再加上本身不是很追求图片的质量，那么会大大节省图片的资源大小，大概为&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;kb。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+ (UIImage *)&lt;span class=&quot;symbol&quot;&gt;resuceImage:&lt;/span&gt;(UIImage *)hdfImage &lt;span class=&quot;symbol&quot;&gt;percent:&lt;/span&gt;(CGFloat)percent &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  UIImage *image = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  NSData *data = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(hdfImage) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   data = UIImageJPEGRepresentation(hdfImage, percent);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   image = [UIImage &lt;span class=&quot;symbol&quot;&gt;imageWithData:&lt;/span&gt;data];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; image;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://lije024.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="UIImage" scheme="http://lije024.github.io/tags/UIImage/"/>
    
      <category term="imageCompress" scheme="http://lije024.github.io/tags/imageCompress/"/>
    
  </entry>
  
  <entry>
    <title>iOS解决滑动页面卡顿的基本技巧</title>
    <link href="http://lije024.github.io/2016/02/24/iOS%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E9%A1%B5%E9%9D%A2%E5%8D%A1%E9%A1%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/"/>
    <id>http://lije024.github.io/2016/02/24/iOS解决滑动页面卡顿的基本技巧/</id>
    <published>2016-02-24T08:04:00.000Z</published>
    <updated>2017-10-18T07:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在开发中我们常常会遇到布局比较复杂的cell,在滑动的时候会导致界面不流畅，出现卡顿的现象，这是由于CPU计算和GPU渲染，之间未及时交换数据丢失帧导致的结果。</p><h1 id="imageView尽量设置为不透明"><a href="#imageView尽量设置为不透明" class="headerlink" title="imageView尽量设置为不透明"></a>imageView尽量设置为不透明</h1><ul><li>opque尽量设置为YES</li></ul><p>当imageView的opque设置为YES的时候其alpha的属性就会无效，imageView的半透明取决于其图片半透明或者imageView本身的背景色合成的图层view是半透明的。</p><p>如果图片全部不是半透明就不会触发图层的blend操作，整个图层就会不透明。</p><p>如果叠加的图片有出现半透明的，就会立马触发图层的blend操作，整个图层不透明。</p><ul><li>opque设为NO</li></ul><p>当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果。</p><ul><li>背景色尽可能设为alpha值为1</li></ul><p>当某一块图层的alpha和其superView的背景色alpha不一样的时候会触发alpha合成操作，这是一项看似很简单但却是非常消耗CPU性能的操作。至于<code>alpha叠加</code>的概念如果有问题可以查看官方说法。</p><h1 id="UIView的背景色设置"><a href="#UIView的背景色设置" class="headerlink" title="UIView的背景色设置"></a>UIView的背景色设置</h1><ul><li><p>UIView的背景色尽量不要设置为clearColor，这样也会触发alpha叠加，在tableView滑动的时候是非常消耗性能的。子视图的背景色尽可能设置成其superView的背景色，这样图层合成的时候不会触发blend操作。</p></li><li><p>最好不使用带alpha通道的图片，如果有alpha尽量让美工取消alpha通道。</p><p>alpha通道的概念特地请教了下公司UI MM,是透明的意思。</p></li></ul><a id="more"></a><h1 id="cell上layer尽量避免使用圆角"><a href="#cell上layer尽量避免使用圆角" class="headerlink" title="cell上layer尽量避免使用圆角"></a>cell上layer尽量避免使用圆角</h1><ul><li><p>在工作中关于滑动界面我们会时常遇到cell行设置头像为圆角等需求，这时候我们尽量避免使用<code>layder.cornerRadius</code>，因为这会触发离屏渲染。离屏渲染很耗时间。</p><p>离屏渲染：是GPU渲染区的一个渲染缓冲区，我们所用的所有显示屏的图形图像都是通过GPU进行渲染，然后显示在屏幕上。GPU负责渲染会把渲染的图形放到缓冲区然后CPU就会发一个垂直信号显示到屏幕。</p></li><li><p>如果要使用圆角，我们可以设置为<code>layer.shouldRasterize = YES</code>，其实这个设置是触发光栅化，可以大大提高渲染的性能。我的理解光栅化就是类似于cell的重用机制。</p><p>光栅化：把第一次渲染好的图层放到缓冲区，那么下次不需要再离屏渲染直接就可以从缓冲区拿去使用。</p></li></ul><h1 id="优化图片的加载方式"><a href="#优化图片的加载方式" class="headerlink" title="优化图片的加载方式"></a>优化图片的加载方式</h1><p> 我们都知道图片的加载方式有两种形式：</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、UIImage *headerImage = [UIImage <span class="symbol">imageNamed:</span>@<span class="string">"haodf.png"</span>；</div><div class="line"><span class="number">2</span>、UIImage * headerImage = [UIImage <span class="symbol">imageWithContentOfFile:</span>@<span class="string">"haodf.png"</span>];</div></pre></td></tr></table></figure><p>我们讲讲两种加载图片方式的区别：</p><ul><li><p>第一种：当我们经常需要这张图片并且仅仅是小图的时候，我们可以使用此种方式加载图片。</p><p>这种方式是把图片缓存在图片缓存区，当我们使用的时候会通过图片的名字也就是通过key的方式去查找图片在缓存区的内存地址。</p><p>当我们使用很多图片的时候系统就会开辟很多内存来存储图片，所以qq、微信我们很多时候都会去清除缓存操作。</p></li><li><p>第二种：当我们使用工程里面的一张大图并且使用次数很少甚至为1次的时候，我们优先会采用这种方式加载图片，这种方式当使用完图片的时候会立即丢弃释放资源，所以对性能不会带来负担。</p></li></ul><h1 id="尽量延迟图片的加载"><a href="#尽量延迟图片的加载" class="headerlink" title="尽量延迟图片的加载"></a>尽量延迟图片的加载</h1><ul><li><p>当我们在滑动页面的时候尤其对于那种布局特别复杂的cell，滑动的时候不要加载图片，当滑动挺值得时候再进行图片的加载。</p><p>我们都知道不管是UITableView还是ScrollView在滚动的时候需要显示东西都是通过runLoop去拿。</p><p>当滚动的时候runLoop会处于NSRunLoopTrackingMode的模式，我们可以通过一个主线程队列dispatch_after或者selfPerformSelector设置runLoop的模式为NSDefaultRunLoopMode模式，就可以做到停止滚动再加载图片。</p><p><code>注：其实严格意义上selfPerformSelector的事件就是在主线程队列中等待。</code></p></li><li><p>优先加载理念</p><p>一直很好奇<code>墨迹天气</code>这款app基本都是很炫的图片，是如何做到滑动时候不卡顿的呢，在cocoachina上有幸认识了一位墨迹天气的大牛，说是采用优先加载的理念，既先展示一部分，当滑动的时候再加载下面的一部分这样就保持流畅。至于具体没透露。</p></li></ul><h1 id="最重要的一点就是避免阻塞主线程"><a href="#最重要的一点就是避免阻塞主线程" class="headerlink" title="最重要的一点就是避免阻塞主线程"></a>最重要的一点就是避免阻塞主线程</h1><ul><li>让图片的绘制、图片的下载、对象的创建、文本的渲染等这些耗时的操作尽可能采用子线程异步的方式去处理，对于layer及UI的操作不得不在主线程里面，只能想办法优化，所以此处给大家推荐Facebook的得力之作ASDK，有兴趣的可以好好研究下，现在好多公司都进行采用。</li></ul><h1 id="争议最多的xib、storyBoard、纯代码的问题"><a href="#争议最多的xib、storyBoard、纯代码的问题" class="headerlink" title="争议最多的xib、storyBoard、纯代码的问题"></a>争议最多的xib、storyBoard、纯代码的问题</h1><ul><li><p>苹果推出storyboard确实为开发者节省了大量的时间，提高了开发效率，但是对于那种<br>复杂的滑动界面，利用storyboard是非常消耗资源的，不信的可以试试用性能工具timeProfie看看cpu所占的性能百分比，其CPU的资源远远大于纯代码布局，我看了一个国外的网站介绍，这两种方式初始化对象分配内存的先后方式完全不一样，至于具体细节有兴趣的可以找相关资料研究。</p></li><li><p>当然对于那种重用性不强固定不怎么变化的界面还是很喜欢storyboard，一蹴而就，节省成本。</p></li></ul><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><ul><li><p>以上都是在项目中遇到这些现象的思考和想法，如果有不对的地方，请加以纠正，谢谢！</p></li><li><p>author: lije</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在开发中我们常常会遇到布局比较复杂的cell,在滑动的时候会导致界面不流畅，出现卡顿的现象，这是由于CPU计算和GPU渲染，之间未及时交换数据丢失帧导致的结果。&lt;/p&gt;
&lt;h1 id=&quot;imageView尽量设置为不透明&quot;&gt;&lt;a href=&quot;#imageView尽量设置为不透明&quot; class=&quot;headerlink&quot; title=&quot;imageView尽量设置为不透明&quot;&gt;&lt;/a&gt;imageView尽量设置为不透明&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;opque尽量设置为YES&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当imageView的opque设置为YES的时候其alpha的属性就会无效，imageView的半透明取决于其图片半透明或者imageView本身的背景色合成的图层view是半透明的。&lt;/p&gt;
&lt;p&gt;如果图片全部不是半透明就不会触发图层的blend操作，整个图层就会不透明。&lt;/p&gt;
&lt;p&gt;如果叠加的图片有出现半透明的，就会立马触发图层的blend操作，整个图层不透明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;opque设为NO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;背景色尽可能设为alpha值为1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当某一块图层的alpha和其superView的背景色alpha不一样的时候会触发alpha合成操作，这是一项看似很简单但却是非常消耗CPU性能的操作。至于&lt;code&gt;alpha叠加&lt;/code&gt;的概念如果有问题可以查看官方说法。&lt;/p&gt;
&lt;h1 id=&quot;UIView的背景色设置&quot;&gt;&lt;a href=&quot;#UIView的背景色设置&quot; class=&quot;headerlink&quot; title=&quot;UIView的背景色设置&quot;&gt;&lt;/a&gt;UIView的背景色设置&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UIView的背景色尽量不要设置为clearColor，这样也会触发alpha叠加，在tableView滑动的时候是非常消耗性能的。子视图的背景色尽可能设置成其superView的背景色，这样图层合成的时候不会触发blend操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最好不使用带alpha通道的图片，如果有alpha尽量让美工取消alpha通道。&lt;/p&gt;
&lt;p&gt;alpha通道的概念特地请教了下公司UI MM,是透明的意思。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://lije024.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="卡顿" scheme="http://lije024.github.io/tags/%E5%8D%A1%E9%A1%BF/"/>
    
  </entry>
  
  <entry>
    <title>ios Monkey性能测试</title>
    <link href="http://lije024.github.io/2016/02/22/ios-Monkey%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>http://lije024.github.io/2016/02/22/ios-Monkey性能测试/</id>
    <published>2016-02-22T03:55:01.000Z</published>
    <updated>2017-10-18T08:50:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>为了减轻测试人员的测试任务，<code>monkey</code>测试是利用测试工具执行相应的测试脚本，实现对程序的执行过程、操作流程进行录制</p><hr><h1 id="利用foneMonkey测试工具包"><a href="#利用foneMonkey测试工具包" class="headerlink" title="利用foneMonkey测试工具包"></a>利用foneMonkey测试工具包</h1><ul><li>下载foneMonkey测试工具包，一般都是.zip的需要解压</li><li>xcode打开工程，添加一个target</li></ul><p><img src="/Users/lije-Mac/Desktop/898456-5422f36bdb08659f.jpeg" alt="MacDown logo"></p><ul><li>重命名</li></ul><p><img src="/Users/lije-Mac/Desktop/898456-7ec9d2baab49aaf7.png" alt="MacDown logo"></p><ul><li>选取刚才创建的target并将解压好的FontMonkey倒入工程目录</li></ul><p><img src="/Users/lije-Mac/Desktop/898456-6d835a83248a1d63.png" alt="MacDown logo"></p><a id="more"></a><ul><li><p>导完工程目录后还需要我们手动添加几个系统框架文件<br>libxml2.dylib、SenTestingKit.framework、QuartzCore.framework</p></li><li><p>修改工程的配置文件 Buile Seting－&gt;Linking-&gt;Other Linker Flags, 改成-all_load</p></li></ul><p><img src="/Users/lije-Mac/Desktop/898456-205f331f5824278e.jpeg" alt="MacDown logo"></p><ul><li><p>选择真机或者模拟器，最好是真机，然后开始编译程序</p></li><li><p>在屏幕下方会出现好几个按钮，点击第二个开始录制程序，完成之后点击保存即可</p></li></ul><p>利用苹果自带的<code>Automation</code>工具，这种方法只适合已经有现成测试脚本或者能够独立写js脚本的开发者，如果没有测试脚本，可以直接使用第一种方法使用现有的测试工具包含测试脚本。</p><hr><ul><li><p>打开xcode的profile,点击instruments里面的<code>Automation</code>，此处就不给截图了，对各位大牛来说这都属于多余</p></li><li><p>如果我们有<code>js</code>脚本点击<code>Automation</code>右下角处有create和add选项，可以直接导入脚本，或者可以复制到代码编译框中</p></li></ul><p><img src="/Users/lije-Mac/Desktop/898456-8c594e47f622e62e.png" alt="MacDown logo"></p><ul><li><p>选择你要进行测试的app</p></li><li><p>当有脚本之后，在<code>Automation</code>左上角有个record，点击开始执行脚本，<br>此处与方法一不同的是：这里不是录制过程，是脚本代码在代替测试人员手动点击，所触发的事件</p></li></ul><p><img src="/Users/lije-Mac/Desktop/898456-48794bf9b9a5ed2d.png" alt="MacDown logo"></p><hr><ul><li>备注</li></ul><p>我们在工程编译的过程中可能会遇到编译无法通过的报错bug,如下图：</p><p><img src="/Users/lije-Mac/Desktop/898456-5fa4277575ea2833.jpg" alt="MacDown logo"></p><p>出现这个我们只要把-all_load的中文格式改成英文即可，如有别的问题继续探讨</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;为了减轻测试人员的测试任务，&lt;code&gt;monkey&lt;/code&gt;测试是利用测试工具执行相应的测试脚本，实现对程序的执行过程、操作流程进行录制&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;利用foneMonkey测试工具包&quot;&gt;&lt;a href=&quot;#利用foneMonkey测试工具包&quot; class=&quot;headerlink&quot; title=&quot;利用foneMonkey测试工具包&quot;&gt;&lt;/a&gt;利用foneMonkey测试工具包&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;下载foneMonkey测试工具包，一般都是.zip的需要解压&lt;/li&gt;
&lt;li&gt;xcode打开工程，添加一个target&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/Users/lije-Mac/Desktop/898456-5422f36bdb08659f.jpeg&quot; alt=&quot;MacDown logo&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重命名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/Users/lije-Mac/Desktop/898456-7ec9d2baab49aaf7.png&quot; alt=&quot;MacDown logo&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选取刚才创建的target并将解压好的FontMonkey倒入工程目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/Users/lije-Mac/Desktop/898456-6d835a83248a1d63.png&quot; alt=&quot;MacDown logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试" scheme="http://lije024.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Monkey" scheme="http://lije024.github.io/tags/Monkey/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods在项目中的使用</title>
    <link href="http://lije024.github.io/2016/02/19/Cocoapods%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://lije024.github.io/2016/02/19/Cocoapods在项目中的使用/</id>
    <published>2016-02-19T06:57:58.000Z</published>
    <updated>2017-10-18T07:29:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Cocoapods是在Mac OSX和iOS应用程序上利用ruby的依赖管理gem来构建的的一款第三库依赖的管理工具，通过它可以很方便的去管理项目中的三方库，随着版本的迭代可以快速升级第三方库版版本，也能够搜索出比较有价值的三方库，同时还为开发者自动配置好编译器的各种设置选项，为开发者节省大量没有技术含量去设置build phasese和link flags.</p><h1 id="Cocoapods的核心组件"><a href="#Cocoapods的核心组件" class="headerlink" title="Cocoapods的核心组件"></a>Cocoapods的核心组件</h1><ol><li><p>Cocoapods/Cocoapod</p><p>该组件包含了Cocoapods的基本功能，每当使用pod命令时都能够激活该组件.</p></li><li><p>Cocoapods/Core </p><p>该组件支持了Cocoapods的Podfile和Podspec文件处理.</p></li><li><p>Podfile </p><p>在此文件里面我们可以高度自定义指定所需的三方库版本号等.</p></li><li><p>Podspec </p><p>该文件描述了一个库是怎样被添加到工程里的，可以列出源文件指定库的依赖关系.</p></li><li><p>Cocoapods/XcodeProj</p><p>创建.xcWorkSpace .xcodeProj，整合所有工程文件.</p></li></ol><h1 id="Cocoapods的安装"><a href="#Cocoapods的安装" class="headerlink" title="Cocoapods的安装"></a>Cocoapods的安装</h1><ul><li>更新ruby源，因为亚马逊的被墙了所以使用淘宝的ruby源</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gem sources --remove <span class="symbol">https:</span>/<span class="regexp">/rubygems.org/</span></div><div class="line">gem sources -a <span class="symbol">https:</span>/<span class="regexp">/ruby.taobao.org/</span></div><div class="line">gem sources -l</div></pre></td></tr></table></figure><ul><li>用gem命令开始安装Cocoapods</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install Cocoapods</div></pre></td></tr></table></figure><blockquote><p>备注</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">如果出现 </div><div class="line">While executing gem ... (Errno::EPERM)</div><div class="line">Operation not permitted - /usr/bin/xcodeproj</div><div class="line">执行 sudo gem install -n /usr/local/bin cocoapods开通权限安装</div></pre></td></tr></table></figure><a id="more"></a><ul><li>创建podfile并自定义需要的三方库</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. touch podfile (创建podfile文件)</div><div class="line"><span class="number">2</span>. vi podfile</div><div class="line"><span class="number">3</span>. platform <span class="symbol">:ios</span></div><div class="line">  pod <span class="string">'SVProgressHud'</span>,       <span class="string">'~&gt; 2.0'</span></div><div class="line">  pod <span class="string">'Reachability'</span>,  <span class="string">'~&gt; 3.0.0'</span></div><div class="line">  pod <span class="string">'AFNetWorking'</span></div><div class="line">  pod <span class="string">'ShareSDK'</span></div></pre></td></tr></table></figure><ul><li>完成三方库定义之后更新设置Cocoapods</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod update （时间会有点久换另一种方式）</div></pre></td></tr></table></figure><ul><li>查找三方库</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search ***</div></pre></td></tr></table></figure><ul><li>在执行pod update 或者pod install的时候屏蔽更新podspec索引</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod install --verbose --no-repo-update（如果被墙了可以用这个）</div></pre></td></tr></table></figure><ul><li>为某个三方库生成podspec文件，指定依赖可以用这个</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec create your_pod_spec_name (会生成一个.podspec的文件)</div></pre></td></tr></table></figure><ul><li>创建私有的pods</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pod <span class="string">'MJRefresh'</span>, <span class="symbol">:podspec</span> =&gt; <span class="string">'https://haodf.com/MJRefresh/ </span></div><div class="line"><span class="string">MJRefresh.podspec'</span></div></pre></td></tr></table></figure><p>此时我们完成了最基本的使用.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上命令都是亲自项目中实践过的包括一些异常，有不恰当的地方尽情指正</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;Cocoapods是在Mac OSX和iOS应用程序上利用ruby的依赖管理gem来构建的的一款第三库依赖的管理工具，通过它可以很方便的去管理项目中的三方库，随着版本的迭代可以快速升级第三方库版版本，也能够搜索出比较有价值的三方库，同时还为开发者自动配置好编译器的各种设置选项，为开发者节省大量没有技术含量去设置build phasese和link flags.&lt;/p&gt;
&lt;h1 id=&quot;Cocoapods的核心组件&quot;&gt;&lt;a href=&quot;#Cocoapods的核心组件&quot; class=&quot;headerlink&quot; title=&quot;Cocoapods的核心组件&quot;&gt;&lt;/a&gt;Cocoapods的核心组件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Cocoapods/Cocoapod&lt;/p&gt;
&lt;p&gt;该组件包含了Cocoapods的基本功能，每当使用pod命令时都能够激活该组件.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cocoapods/Core &lt;/p&gt;
&lt;p&gt;该组件支持了Cocoapods的Podfile和Podspec文件处理.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Podfile &lt;/p&gt;
&lt;p&gt;在此文件里面我们可以高度自定义指定所需的三方库版本号等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Podspec &lt;/p&gt;
&lt;p&gt;该文件描述了一个库是怎样被添加到工程里的，可以列出源文件指定库的依赖关系.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cocoapods/XcodeProj&lt;/p&gt;
&lt;p&gt;创建.xcWorkSpace .xcodeProj，整合所有工程文件.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Cocoapods的安装&quot;&gt;&lt;a href=&quot;#Cocoapods的安装&quot; class=&quot;headerlink&quot; title=&quot;Cocoapods的安装&quot;&gt;&lt;/a&gt;Cocoapods的安装&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;更新ruby源，因为亚马逊的被墙了所以使用淘宝的ruby源&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;gem sources --remove &lt;span class=&quot;symbol&quot;&gt;https:&lt;/span&gt;/&lt;span class=&quot;regexp&quot;&gt;/rubygems.org/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;gem sources -a &lt;span class=&quot;symbol&quot;&gt;https:&lt;/span&gt;/&lt;span class=&quot;regexp&quot;&gt;/ruby.taobao.org/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;gem sources -l&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;用gem命令开始安装Cocoapods&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo gem install Cocoapods&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;备注&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;如果出现 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;While executing gem ... (Errno::EPERM)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Operation not permitted - /usr/bin/xcodeproj&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;执行 sudo gem install -n /usr/local/bin cocoapods开通权限安装&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="效率" scheme="http://lije024.github.io/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="Coaoapods" scheme="http://lije024.github.io/tags/Coaoapods/"/>
    
  </entry>
  
</feed>
